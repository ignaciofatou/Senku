/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package paquete;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * @author Ignacio
 */
public class PanelTablero extends javax.swing.JPanel {

    private static final int RADIO_BTN   = 15;
    private static final int MARGIN_BTN  = 5;
    private final     String COL_NORMAL  = "FF0000";
    private final     String COL_SELECC  = "0000FF";
    private final        int NORMAL      = 0;
    private final        int SELECC      = 1;
    private final        int VACIO       = 2;
    private final        int OUT_PANEL   = 3;

    private int[][] tablero;
    private ArrayList<Movimiento> movimientos;
    
    private boolean panelActivo;

    //Constantes y Variables Para el Cronometro
    private final static int ONE_SECOND = 1000;
    private int segundos = 0;
    private int minutos = 0;
    private final int TIEMPO_MAXIMO = 2;

    /**
     * Creates new form PanelBotones
     */
    public PanelTablero() {
        initComponents();
        panelActivo = false;
    }

    public void inicializaTablero(int[][] p_Tablero){        

        //Cargamos los Datos del Tablero desde su Copia
        tablero = p_Tablero;

        //ArrayList para guardar los movimientos
        movimientos = new ArrayList();
    }

    //Reiniciamos el Tablero
    public void reiniciarTablero(int[][] p_Tablero){
        //Reinicia los circulos del Tablero
        inicializaTablero(p_Tablero);
        this.repaint();
        panelActivo = false;
        jLNumMovimientos.setText("0");
        
        //Reiniciamos el Cronometro
        t.restart();
        t.stop();
        segundos = 0;
        minutos = 0;
        jLTiempo.setText("00:00");
    }
    
    @Override
    public void paint(Graphics g) {
        super.paint(g);

        if (tablero != null){
            //Obtenemos el color en formato HSB
            float[] colorHSB_Normal = getColorHSB(COL_NORMAL);
            float[] colorHSB_Selecc = getColorHSB(COL_SELECC);
            int posX = MARGIN_BTN;
            int posY = MARGIN_BTN;
            int size = tablero.length;

            for (int y = 0; y < size; y++) {

                for (int x = 0; x < size; x++) {

                    if (tablero[y][x] == NORMAL) {
                        pintaCirculo3D(g, posX, posY, RADIO_BTN, colorHSB_Normal);
                    } else if (tablero[y][x] == SELECC) {
                        pintaCirculo3D(g, posX, posY, RADIO_BTN, colorHSB_Selecc);
                    } else if (tablero[y][x] == VACIO) {
                        pintaCirculoBlanco(g, posX, posY, RADIO_BTN);
                    }

                    posX = posX + (RADIO_BTN * 2) + MARGIN_BTN;
                }
                posX = MARGIN_BTN;
                posY = posY + (RADIO_BTN * 2) + MARGIN_BTN;
            }
        }
    }
    
    private void pintaCirculoBlanco(Graphics g, int posX, int posY, int radio){
        int size = radio * 2;
        g.setColor(Color.WHITE);        
        g.fillOval(posX, posY, size, size);
    }
    private void pintaCirculo3D(Graphics g, int posX, int posY, int radio, float[] colorHSB){
        
        //Calculamos el TamaÃ±o del Circulo
        int size = radio * 2;
        float resta = (float)(0.9/radio);
        float saturation = colorHSB[1];

        for (int x=size; x > 1; x=x-2){
            g.setColor(Color.getHSBColor(colorHSB[0], saturation, colorHSB[2]));
            g.fillOval(posX, posY, x, x);

            //Decrementamos Saturacion
            saturation = (float)saturation - resta;

            //Incrementamos la posicion del siguiente circulo
            if ((x % 4) == 0.0){
                posY++;
                posX++;
            }
        }
    }
    private float[] getColorHSB(String color){
        try{
            //Convertimos el Color en Formato HSB
            int red   = Integer.parseInt(color.substring(0, 2), 16);                
            int green = Integer.parseInt(color.substring(2, 4), 16);
            int blue  = Integer.parseInt(color.substring(4, 6), 16);        
            return Color.RGBtoHSB(red, green, blue, null);
        } catch (Exception ex){
            System.out.println("Error en Conversion a Hexadecimal: "+ ex.getMessage());
        }
        return  null;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLNumMovimientos = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLTiempo = new javax.swing.JLabel();

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        jLabel1.setText("Movimientos:");

        jLNumMovimientos.setText("0");

        jLabel2.setText("Tiempo:");

        jLTiempo.setText("00:00");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(339, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLTiempo))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLNumMovimientos)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLTiempo))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLNumMovimientos))
                .addContainerGap(304, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked

        //Si el Panel esta Activo
        if (panelActivo){
            gestionaCirculos(evt.getY(), evt.getX());
            this.repaint();
        }
    }//GEN-LAST:event_formMouseClicked
    private void gestionaCirculos(int coordenadaY, int coordenadaX){

        int espacioOcupado = (RADIO_BTN * 2) + MARGIN_BTN;
        
        int posY = (coordenadaY - (MARGIN_BTN / 2)) / espacioOcupado;
        int posX = (coordenadaX - (MARGIN_BTN / 2)) / espacioOcupado;
        
        //Gestionamos si se Marca o no la posicion seleccionada
        marcaDesmarcaSeleccionado(posY, posX);
    }
    private void marcaDesmarcaSeleccionado(int newPosY, int newPosX){
        
        //Si ya hay uno Seleccionado anteriormente
        if (hayUnoSeleccionado()){
            //Obtenemos la Posicion del Circulo Seleccionado
            int[] pos = getPosicionSeleccionado();

            //Si hemos Marcado una que ya esta Seleccionada -> Deseleccionamos
            if ((newPosY == pos[0]) && (newPosX == pos[1]))
                tablero[newPosY][newPosX] = NORMAL;
            //Si hemos Marcado uno que esta vacio -> Comprobamos si es Adyacente
            //al que se marco anteriormente
            else if (tablero[newPosY][newPosX] == VACIO){
                //Creamos el Nuevo Movimiento
                Movimiento newMovimiento = new Movimiento(pos[0], pos[1], newPosY, newPosX);
                
                //En una de las coordenadas debe haber 2 posiciones de diferencia
                if (newMovimiento.isMovimientoValido()){
                    //Si la Posicion de en medio contiene un circulo --> Movemos
                    if (tablero[newMovimiento.getMedY()][newMovimiento.getMedX()] == NORMAL){
                        //Realizamos el Movimiento
                        realizaMovimiento(newMovimiento);
                    }
                }                
            }
        }
        //Si no hay ninguna Seleccionado y es Normal -> Seleccionamos
        else if (tablero[newPosY][newPosX] == NORMAL)
            tablero[newPosY][newPosX] = SELECC;
    }

    //Realizamos los cambios del Movimiento en la Matriz
    private void realizaMovimiento(Movimiento newMovimiento){
        //Realizamos los cambios del Movimiento en la Matriz
        tablero[newMovimiento.getNewY()][newMovimiento.getNewX()] = NORMAL;
        tablero[newMovimiento.getOldY()][newMovimiento.getOldX()] = VACIO;
        tablero[newMovimiento.getMedY()][newMovimiento.getMedX()] = VACIO;
        
        //Guarda el Movimiento Realizado
        getMovimientos().add(newMovimiento);

        //Incrementamos el Numero de Movimientos
        jLNumMovimientos.setText(String.valueOf(Integer.valueOf(jLNumMovimientos.getText()) + 1));

        //Comprobamos si ha finalizado la Partida
        compruebaFinPartida();
    }
    //Deshacemos el ultimo Movimiento Realizado
    public void deshacerMovimiento(){

        //Si hay al Menos un Movimiento
        if ((getMovimientos().size()) > 0){
            
            //Posicin Real en el ArrayList
            int posUlt = getMovimientos().size() - 1;
            
            //Obtenemos la Posicion del Ultimo Movimiento Realizado
            int antPosY = getMovimientos().get(posUlt).getOldY();
            int antPosX = getMovimientos().get(posUlt).getOldX();
            int newPosY = getMovimientos().get(posUlt).getNewY();
            int newPosX = getMovimientos().get(posUlt).getNewX();
            int posMedY = getMovimientos().get(posUlt).getMedY();
            int posMedX = getMovimientos().get(posUlt).getMedX();

            //Realizamos los cambios del Movimiento en la Matriz
            tablero[newPosY][newPosX] = VACIO;
            tablero[antPosY][antPosX] = NORMAL;
            tablero[posMedY][posMedX] = NORMAL;

            //Borramos el Ultimo Movimiento
            getMovimientos().remove(getMovimientos().size()-1);

            //Decrementamos el Numero de Movimientos
            jLNumMovimientos.setText(String.valueOf(Integer.valueOf(jLNumMovimientos.getText()) - 1));

            //Repintamos el Panel
            this.repaint();
        }
    }
    
    //Comprueba si se ha perdido la partida o si se ha ganado
    private void compruebaFinPartida(){

        int numNormal = 0;
        boolean perdido = true;
        int size = tablero.length;

        for (int y=0; y<size; y++){
            for (int x=0; x<size; x++){
                //Si la Posicion contiene una bola Normal
                if (tablero[y][x] == NORMAL){
                    numNormal++;

                    //Si de momento no encuentra una Bola adyacente
                    if (perdido){
                        //Compruebo si tiene otra Normal Adyacente en Vertical
                        if ((y >= 1) && (tablero[y - 1][x] == NORMAL)){
                            //Si Delante de la Bola esta vacio o
                            //Detras de la Adyacente esta vacio
                            if ((((y + 1) < size) && (tablero[y + 1][x] == VACIO)) ||
                                (((y - 2) >= 0    ) && (tablero[y - 2][x] == VACIO)))
                                perdido = false;
                        }
                        //Compruebo si tiene otra Normal Adyacente en Horizontal
                        if ((x >= 1) && (tablero[y][x - 1] == NORMAL)){
                            //Si Arriba de la Bola esta cacio o
                            //Abajo de la Adyacente esta vacio
                            if ((((x + 1) < size) && (tablero[y][x + 1] == VACIO)) ||
                                (((x - 2) >= 0    ) && (tablero[y][x - 2] == VACIO)))
                                perdido = false;
                        }
                    }
                }
            }
        }
        //Si solo hay unoa Bola Normal -> Ha ganado la partida
        if (numNormal == 1)
            setFinPartida(true);
        //Si no ha encontrado bolas Adyacentes -> Ha perdido la partida
        else if (perdido)
            setFinPartida(false);
    }
    
    
    private boolean hayUnoSeleccionado(){
        int size = tablero.length;
        for (int y=0; y<size; y++)
            for (int x=0; x<size; x++)
                if (tablero[y][x] == SELECC)
                    return true;
        
        return false;
    }
    private int[] getPosicionSeleccionado(){
        int[] pos = new int[2];
        int size = tablero.length;
        for (int y=0; y<size; y++)
            for (int x=0; x<size; x++)
                if (tablero[y][x] == SELECC){
                    pos[0]=y;
                    pos[1]=x;
                }                    
        
        return pos;
    }
    
    private void setFinPartida(boolean ganada){
        
        //Elementos Comunes
        panelActivo = false;
        
        //Paramos el Cronometro
        t.stop();        
        
        //Ha ganado la Partida
        if (ganada){
            //Mostramos un Mensaje de Partida Ganada
            JOptionPane.showMessageDialog(
                    null,
                    "!!Bienn, ha ganado!! - Fin de la partida",
                    "Ha ganado",
                    JOptionPane.INFORMATION_MESSAGE);
        }
        //Ha perdido la Partida
        else{
            //Mostramos un Mensaje de Partida Perdida
            JOptionPane.showMessageDialog(
                    null,
                    "!!Ohh, ha perdido!! - Fin de la partida",
                    "Ha perdido",
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }
    
    public void setPanelActivo(boolean panelActivo) {
        this.panelActivo = panelActivo;
        
        if (panelActivo){
            t.start();
        }
    }
    public ArrayList<Movimiento> getMovimientos() {
        return movimientos;
    }
    
    //Codigo para el Cronometro
    //Creamos el objeto Timer (gracias a la ayuda de Anabel Coronel)
    javax.swing.Timer t = new javax.swing.Timer(ONE_SECOND, new ActionListener() {
        public void actionPerformed(ActionEvent ae) {
            segundos++;

            if (segundos == 60) {
                minutos++;
                segundos = 0;
            }
            if (minutos == TIEMPO_MAXIMO) {
                //Mostramos un Mensaje de Partida Perdida
                setFinPartida(false);
                
                t.stop();
            }
            //Mostramos las Minutos y Segundos
            DecimalFormat formato = new DecimalFormat("00");
            jLTiempo.setText(formato.format(minutos) + ":"
                    + formato.format(segundos));
        }
    }); 


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLNumMovimientos;
    private javax.swing.JLabel jLTiempo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    // End of variables declaration//GEN-END:variables


}
